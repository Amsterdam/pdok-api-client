# coding: utf-8

"""
    Locatieserver

    De PDOK Locatieserver is een open en gratis geocodeerservice waarmee gezocht kan worden op gegevens uit verschillende overheidsregistraties (bijvoorbeeld adressen, percelen en rijkswegen) om vervolgens doorgestuurd te worden naar de locatie van de zoekopdracht.  De Locatieserver bestaat uit meerdere RESTful API's die eenvoudig geïntegreerd kunnen worden in viewers en/of applicaties. De API's zijn open, gratis en bevatten gegevens uit verschillende overheidsregistraties zoals adressen (postcodes, straten, huisnummer), kadastrale percelen, wegen en hectometerpalen maar ook woonplaatsen, wijken, buurten en waterschappen. De onderliggende gegevens worden zeer frequent bijgewerkt.  De Locatieserver bestaat totaal uit vier RESTful API's die gepubliceerd worden volgens de Open API Specificatie [https://api.pdok.nl/bzk/locatieserver/search/v3_1/ui/](https://api.pdok.nl/bzk/locatieserver/search/v3_1/ui/). Hiermee zijn de mogelijkheden van de Locatieserver API's (input en output) gedocumenteerd.  Het zoeken op gegevens wordt vereenvoudigd met behulp van de **Suggest API** die de mogelijkheid biedt om een (gedeelte van een) zoekopdracht op te voeren, waarnaar er suggesties teruggegeven worden. Dankzij slimme technieken als auto-aanvullen en ondersteuning van alternatieve schrijfwijzen en synoniemen vinden gebruikers snel waar ze naar op zoek zijn. Het is ook mogelijk om bij zoekopdrachten een locatie van de gebruiker mee te geven zodat suggesties op basis van die locatie worden gesorteerd.  Zodra er op basis van suggesties van de Suggest API een keuze is gemaakt, wordt de **Lookup API** aangeroepen, welke o.a. een (versimpelde) geometrie van de zoekopdracht teruggeeft. Hiermee kan een gebruiker naar de locatie van de zoekopdracht worden gestuurd op de kaart. Dankzij de highlight functie kan het betreffende gegeven (object) vervolgens worden opgelicht op de kaart.  De suggest- en de lookup API werken dus als een tweetrapsraket. Er is ook een mogelijkheid om vrij te zoeken (klassiek geocoderen) met de **Free API** waar zonder tussenkomst van suggesties de API direct resultaten teruggeeft op basis van de zoekopdracht.  De **Reverse API** biedt de mogelijkheid om een locatie (punt geometrie) op te geven om vervolgens verschillende gegevens in een range rondom deze locatie te ontvangen. Bijvoorbeeld het ophalen van alle adressen of wegen in de buurt (op basis van de opgegeven locatie). Dit wordt ook wel Reverse Geocoderen genoemd. Met de **Reverse API** kan je op basis van een coördinaat en een range (bijvoorbeeld 1 kilometer) de gewenste gegevens binnen die range opvragen en visualiseren.  De Locatieserver is primair een geocodeerservice. Voor andere doeleinden zoals het rechtstreeks opvragen van bepaalde gegevens of het downloaden van bulk data biedt PDOK andere mogelijkheden via webservices en/of downloads.  Meer informatie over de Locatieserver is ook te vinden op de Locatieserver Wiki op [Github](https://github.com/PDOK/locatieserver/wiki/API-Locatieserver) of volg discussies op het [PDOK forum](https://geoforum.nl/c/applicaties-en-diensten/locatieserver/27). 

    The version of the OpenAPI document: v3_1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Optional
from typing_extensions import Self

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(
        self, 
        status=None, 
        reason=None, 
        http_resp=None,
        *,
        body: Optional[str] = None,
        data: Optional[Any] = None,
    ) -> None:
        self.status = status
        self.reason = reason
        self.body = body
        self.data = data
        self.headers = None

        if http_resp:
            if self.status is None:
                self.status = http_resp.status
            if self.reason is None:
                self.reason = http_resp.reason
            if self.body is None:
                try:
                    self.body = http_resp.data.decode('utf-8')
                except Exception:
                    pass
            self.headers = http_resp.getheaders()

    @classmethod
    def from_response(
        cls, 
        *, 
        http_resp, 
        body: Optional[str], 
        data: Optional[Any],
    ) -> Self:
        if http_resp.status == 400:
            raise BadRequestException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 401:
            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 403:
            raise ForbiddenException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 404:
            raise NotFoundException(http_resp=http_resp, body=body, data=data)

        # Added new conditions for 409 and 422
        if http_resp.status == 409:
            raise ConflictException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 422:
            raise UnprocessableEntityException(http_resp=http_resp, body=body, data=data)

        if 500 <= http_resp.status <= 599:
            raise ServiceException(http_resp=http_resp, body=body, data=data)
        raise ApiException(http_resp=http_resp, body=body, data=data)

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\n"\
                        "Reason: {1}\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\n".format(
                self.headers)

        if self.data or self.body:
            error_message += "HTTP response body: {0}\n".format(self.data or self.body)

        return error_message


class BadRequestException(ApiException):
    pass


class NotFoundException(ApiException):
    pass


class UnauthorizedException(ApiException):
    pass


class ForbiddenException(ApiException):
    pass


class ServiceException(ApiException):
    pass


class ConflictException(ApiException):
    """Exception for HTTP 409 Conflict."""
    pass


class UnprocessableEntityException(ApiException):
    """Exception for HTTP 422 Unprocessable Entity."""
    pass


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result
